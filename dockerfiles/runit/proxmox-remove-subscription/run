#!/bin/bash
exec 2>&1

SERVICE_NAME="proxmox-remove-subscription"
PROXMOXLIB="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
PROXMOXLIB_DIR="/usr/share/javascript/proxmox-widget-toolkit"
PATCH_MARKER="NoMoreNagging"

# Environment variables with defaults
PBS_ENTERPRISE=${PBS_ENTERPRISE:-"no"}
PBS_NO_SUBSCRIPTION=${PBS_NO_SUBSCRIPTION:-"yes"}
DISABLE_SUBSCRIPTION_NAG=${DISABLE_SUBSCRIPTION_NAG:-"yes"}

# Directories that may contain subscription-related JS
WATCH_DIRS=(
    "$PROXMOXLIB_DIR"
    "/usr/share/javascript/proxmox-backup"
    "/usr/share/pbs-docs"
    "/usr/share/javascript/pbs"
)

log() {
    echo "[${SERVICE_NAME}] $1"
}

log "Configuration:"
log "  PBS_ENTERPRISE=${PBS_ENTERPRISE}"
log "  PBS_NO_SUBSCRIPTION=${PBS_NO_SUBSCRIPTION}"
log "  DISABLE_SUBSCRIPTION_NAG=${DISABLE_SUBSCRIPTION_NAG}"

VERSION="$(awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release)"

# =============================================================================
# configure_repos - Set up apt repositories
# =============================================================================
configure_repos() {
    if [ "${PBS_ENTERPRISE}" = "no" ] || [ "${PBS_ENTERPRISE}" = "false" ]; then
        log "Disabling enterprise repository..."
        echo "# deb https://enterprise.proxmox.com/debian/pbs ${VERSION} pbs-enterprise" > /etc/apt/sources.list.d/pbs-enterprise.list
    fi

    if [ "${PBS_NO_SUBSCRIPTION}" = "yes" ] || [ "${PBS_NO_SUBSCRIPTION}" = "true" ]; then
        log "Enabling no-subscription repository..."
        echo "deb http://download.proxmox.com/debian/pbs ${VERSION} pbs-no-subscription" > /etc/apt/sources.list.d/pbs-install-repo.list
    fi
}

# =============================================================================
# apply_patches - Apply subscription nag patches to a single JS file
# =============================================================================
apply_patches() {
    local target="$1"

    if [ ! -f "$target" ]; then
        log "Target file not found: $target"
        return 1
    fi

    # Check if already patched
    if grep -q "$PATCH_MARKER" "$target" 2>/dev/null; then
        log "Already patched: $(basename "$target")"
        return 0
    fi

    log "Applying patches to: $(basename "$target")"

    # Backup original if not already done
    [ ! -f "${target}.original" ] && cp "$target" "${target}.original"

    # Create a temporary file for complex transformations
    local tmpfile="${target}.patching"
    cp "$target" "$tmpfile"

    # -----------------------------------------------------------------
    # PHASE 1: Status check patterns (desktop & mobile)
    # Flips subscription status comparison logic so checks always pass
    # -----------------------------------------------------------------
    sed -i \
        -e "s/res\.data\.status\.toLowerCase() !== 'active'/res.data.status.toLowerCase() === '${PATCH_MARKER}'/g" \
        -e "s/res\.data\.status\.toLowerCase() !== \"active\"/res.data.status.toLowerCase() === \"${PATCH_MARKER}\"/g" \
        -e "s/data\.status !== 'active'/data.status === '${PATCH_MARKER}'/g" \
        -e "s/data\.status !== \"active\"/data.status === \"${PATCH_MARKER}\"/g" \
        -e "s/data\.status\.toLowerCase() !== 'active'/data.status.toLowerCase() === '${PATCH_MARKER}'/g" \
        -e "s/data\.status\.toLowerCase() !== \"active\"/data.status.toLowerCase() === \"${PATCH_MARKER}\"/g" \
        -e "s/\.status\.toLowerCase() !== 'active'/.status.toLowerCase() === '${PATCH_MARKER}'/g" \
        -e "s/\.status\.toLowerCase() !== \"active\"/.status.toLowerCase() === \"${PATCH_MARKER}\"/g" \
        "$tmpfile"

    # -----------------------------------------------------------------
    # PHASE 2: Subscription text replacements (desktop & mobile)
    # -----------------------------------------------------------------
    sed -i \
        -e "s/No valid subscription/Subscription OK/g" \
        -e "s/There is no subscription key/Subscription OK/g" \
        -e "s/Your subscription status is/Subscription status:/g" \
        -e "s/You do not have a valid subscription/Subscription OK/g" \
        -e "s/No Subscription/Active/g" \
        -e "s/subscription status: none/subscription status: active/gi" \
        -e "s/pbs-hierarchical-no-subscription-key/pbs-hierarchical-active-subscription/g" \
        "$tmpfile"

    # -----------------------------------------------------------------
    # PHASE 3: Mobile-specific nag function disabling
    # -----------------------------------------------------------------
    sed -i \
        -e "s/showSubscriptionNag\s*(/showSubscriptionNag_disabled(/g" \
        -e "s/Proxmox\.Utils\.checked_command\s*(\s*function/Proxmox.Utils.checked_command_disabled(function/g" \
        "$tmpfile"

    # -----------------------------------------------------------------
    # PHASE 4: Perl multiline regex for complex patterns
    # -----------------------------------------------------------------
    if command -v perl >/dev/null 2>&1; then
        perl -i -0pe '
            # Disable the subscription popup Ext.Msg.show call
            s/(Ext\.Msg\.show\s*\(\s*\{[^}]*title\s*:\s*["\x27]No valid subscription)/if(false) { $1/g;

            # Short-circuit getSubscriptionStatus function
            s/(getSubscriptionStatus\s*:\s*function)/${1}_disabled/g;
        ' "$tmpfile" 2>/dev/null || true
    fi

    # -----------------------------------------------------------------
    # PHASE 5: ExtJS dialog/modal patterns
    # -----------------------------------------------------------------
    sed -i \
        -e "s/title:\s*gettext('No valid subscription')/title: gettext('Subscription OK')/g" \
        -e "s/title:\s*\"No valid subscription\"/title: \"Subscription OK\"/g" \
        -e "s/title:\s*'No valid subscription'/title: 'Subscription OK'/g" \
        -e "s/msg:\s*Proxmox\.Utils\.getNoSubKeyHtml/msg: function() { return ''; } \/\/ /g" \
        -e "s/getNoSubKeyHtml\s*(/getNoSubKeyHtml_disabled(/g" \
        "$tmpfile"

    # -----------------------------------------------------------------
    # PHASE 6: CSS class-based subscription indicators
    # -----------------------------------------------------------------
    sed -i \
        -e "s/x-masked-subscription/x-masked-subscription-hidden/g" \
        -e "s/pve-subscription-warning/pve-subscription-ok/g" \
        -e "s/fa-exclamation-triangle\(.*subscription\)/fa-check-circle\1/g" \
        "$tmpfile"

    # Move patched file into place atomically
    mv "$tmpfile" "$target"

    # Verify patch was applied
    if grep -q "$PATCH_MARKER" "$target" 2>/dev/null; then
        log "Patches applied successfully to $(basename "$target")"
        return 0
    elif grep -q "Subscription OK" "$target" 2>/dev/null; then
        log "Patches applied (text replacement verified) to $(basename "$target")"
        return 0
    else
        log "Warning: Patch markers not found in $(basename "$target") - patterns may have changed"
        grep -n -i "subscription\|checked_command" "$target" 2>/dev/null | head -10 || true
        return 1
    fi
}

# =============================================================================
# patch_all_js_files - Scan directory for JS files with subscription code
# =============================================================================
patch_all_js_files() {
    local dir="$1"
    local patched=0

    if [ ! -d "$dir" ]; then
        return 1
    fi

    # Use find for recursive search (more portable than globstar)
    while IFS= read -r -d '' jsfile; do
        # Only patch files that contain subscription-related code
        if grep -qiE "subscription|checked_command|NoSubKey" "$jsfile" 2>/dev/null; then
            apply_patches "$jsfile"
            patched=$((patched + 1))
        fi
    done < <(find "$dir" -name "*.js" -type f -print0 2>/dev/null)

    [ $patched -gt 0 ] && log "Patched $patched file(s) in $dir"
    return 0
}

# =============================================================================
# watch_and_patch - Monitor directories for changes and re-apply patches
# =============================================================================
watch_and_patch() {
    # Build list of existing directories to watch
    local existing_dirs=()
    for dir in "${WATCH_DIRS[@]}"; do
        [ -d "$dir" ] && existing_dirs+=("$dir")
    done

    if [ ${#existing_dirs[@]} -eq 0 ]; then
        log "No directories to watch, sleeping..."
        exec sleep infinity
    fi

    log "Watching for changes in: ${existing_dirs[*]}"

    if command -v inotifywait >/dev/null 2>&1; then
        # Efficient inotify-based watching
        while true; do
            changed_file=$(inotifywait -q -e create -e modify -e moved_to \
                --format '%w%f' "${existing_dirs[@]}" 2>/dev/null)

            sleep 1  # Let writes complete

            if [[ "$changed_file" == *.js ]]; then
                log "Change detected: $(basename "$changed_file")"
                if grep -qiE "subscription|checked_command|NoSubKey" "$changed_file" 2>/dev/null; then
                    apply_patches "$changed_file"
                fi
            fi
        done
    else
        # Fallback: periodic polling
        log "inotifywait not available, using 60s polling"
        while true; do
            sleep 60
            for dir in "${existing_dirs[@]}"; do
                patch_all_js_files "$dir"
            done
        done
    fi
}

# =============================================================================
# MAIN EXECUTION
# =============================================================================
configure_repos

if [ "${DISABLE_SUBSCRIPTION_NAG}" != "yes" ] && [ "${DISABLE_SUBSCRIPTION_NAG}" != "true" ]; then
    log "Subscription nag removal disabled by configuration"
    exec sleep infinity
fi

log "Starting subscription nag removal..."

# Wait for the primary JS file to appear (max 2 minutes)
waited=0
while [ ! -f "$PROXMOXLIB" ] && [ $waited -lt 120 ]; do
    sleep 2
    waited=$((waited + 2))
done

# Initial patch pass on all directories
for dir in "${WATCH_DIRS[@]}"; do
    patch_all_js_files "$dir"
done

# Enter watch loop
watch_and_patch
